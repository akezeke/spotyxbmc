Index: xbmc/XBApplicationEx.cpp
===================================================================
--- xbmc/XBApplicationEx.cpp	(revision 27482)
+++ xbmc/XBApplicationEx.cpp	(arbetskopia)
@@ -21,6 +21,9 @@
 #include "system.h"
 #include "XBApplicationEx.h"
 #include "utils/log.h"
+//spotify
+#include "spotinterface.h"
+
 #ifdef HAS_PERFORMANCE_SAMPLE
 #include "utils/PerformanceSample.h"
 #else
@@ -86,6 +89,12 @@
     try
     {
 #endif
+      //spotify, advance the spotifyAPI
+      if (g_advancedSettings.m_spotifyEnable)
+      {
+        g_spotifyInterface->processEvents();
+      }
+
       Process();
       //reset exception count
       processExceptionCount = 0;
Index: xbmc/GUIViewState.cpp
===================================================================
--- xbmc/GUIViewState.cpp	(revision 27482)
+++ xbmc/GUIViewState.cpp	(arbetskopia)
@@ -60,6 +60,10 @@
   if (url.GetProtocol()=="musicsearch")
     return new CGUIViewStateMusicSearch(items);
 
+    //spotify
+  if (url.GetProtocol()=="spotify")
+    return new CGUIViewStateSpotifyLibrary(items);
+
   if (items.IsSmartPlayList())
   {
     if (items.GetContent() == "songs")
Index: xbmc/cores/paplayer/Makefile.in
===================================================================
--- xbmc/cores/paplayer/Makefile.in	(revision 27482)
+++ xbmc/cores/paplayer/Makefile.in	(arbetskopia)
@@ -9,7 +9,7 @@
 
 CFLAGS+=-DHAS_ALSA
 
-SRCS=AC3CDDACodec.cpp AC3Codec.cpp ADPCMCodec.cpp AIFFcodec.cpp AudioDecoder.cpp CDDAcodec.cpp CodecFactory.cpp VGMCodec.cpp FLACcodec.cpp GYMCodec.cpp MP3codec.cpp NSFCodec.cpp OGGcodec.cpp ReplayGain.cpp SIDCodec.cpp TimidityCodec.cpp WAVcodec.cpp WAVPackcodec.cpp YMCodec.cpp DVDPlayerCodec.cpp DTSCodec.cpp DTSCDDACodec.cpp PAPlayer.cpp OggCallback.cpp ModplugCodec.cpp
+SRCS=spotifyCodec.cpp AC3CDDACodec.cpp AC3Codec.cpp ADPCMCodec.cpp AIFFcodec.cpp AudioDecoder.cpp CDDAcodec.cpp CodecFactory.cpp VGMCodec.cpp FLACcodec.cpp GYMCodec.cpp MP3codec.cpp NSFCodec.cpp OGGcodec.cpp ReplayGain.cpp SIDCodec.cpp TimidityCodec.cpp WAVcodec.cpp WAVPackcodec.cpp YMCodec.cpp DVDPlayerCodec.cpp DTSCodec.cpp DTSCDDACodec.cpp PAPlayer.cpp OggCallback.cpp ModplugCodec.cpp
 
 ifeq (@USE_ASAP_CODEC@,1)
   SRCS+=ASAPCodec.cpp
Index: xbmc/cores/paplayer/CodecFactory.cpp
===================================================================
--- xbmc/cores/paplayer/CodecFactory.cpp	(revision 27482)
+++ xbmc/cores/paplayer/CodecFactory.cpp	(arbetskopia)
@@ -20,6 +20,9 @@
  */
 
 #include "system.h"
+//spotify
+#include "spotifyCodec.h"
+
 #include "XBAudioConfig.h"
 #include "CodecFactory.h"
 #include "MP3codec.h"
@@ -54,7 +57,10 @@
 
 ICodec* CodecFactory::CreateCodec(const CStdString& strFileType)
 {
-  if (strFileType.Equals("mp3") || strFileType.Equals("mp2"))
+  //spotify
+  if (strFileType.Equals("spotify"))
+    return new SpotifyCodec();
+  else if (strFileType.Equals("mp3") || strFileType.Equals("mp2"))
     return new MP3Codec();
   else if (strFileType.Equals("ape") || strFileType.Equals("mac"))
     return new DVDPlayerCodec();
Index: xbmc/cores/paplayer/PAPlayer.cpp
===================================================================
--- xbmc/cores/paplayer/PAPlayer.cpp	(revision 27482)
+++ xbmc/cores/paplayer/PAPlayer.cpp	(arbetskopia)
@@ -33,6 +33,8 @@
 #include "../AudioRenderers/AudioRendererFactory.h"
 #include "../../utils/TimeUtils.h"
 #include "utils/log.h"
+//spotify
+#include "spotifyCodec.h"
 
 #ifdef _LINUX
 #define XBMC_SAMPLE_RATE 44100
@@ -536,7 +538,13 @@
     UpdateCacheLevel();
 
     // check whether we should queue the next file up
-    if ((GetTotalTime64() > 0) && GetTotalTime64() - GetTime() < TIME_TO_CACHE_NEXT_FILE + m_crossFading * 1000L && !m_cachingNextFile)
+    bool isSpotifyFree = true;
+    if (m_decoder[m_currentDecoder].GetCodec()->m_CodecName == "spotify")
+    {
+       //spotify, we can only get the new file if the old one is done reading
+       isSpotifyFree = SpotifyCodec::spotifyPlayerIsFree();
+    }
+    if (isSpotifyFree && (GetTotalTime64() > 0) && GetTotalTime64() - GetTime() < TIME_TO_CACHE_NEXT_FILE + m_crossFading * 1000L && !m_cachingNextFile)
     { // request the next file from our application
       m_callback.OnQueueNextItem();
       m_cachingNextFile = true;
Index: xbmc/Application.cpp
===================================================================
--- xbmc/Application.cpp	(revision 27482)
+++ xbmc/Application.cpp	(arbetskopia)
@@ -23,6 +23,9 @@
   #include "config.h"
 #endif
 #include "Application.h"
+//spotify
+#include "spotinterface.h"
+
 #include "utils/Builtins.h"
 #include "Splash.h"
 #include "KeyboardLayoutConfiguration.h"
@@ -344,6 +347,13 @@
 
 CApplication::~CApplication(void)
 {
+  //spotify
+  if (g_advancedSettings.m_spotifyEnable)
+  {
+      delete g_spotifyInterface;
+  }
+  g_spotifyInterface = 0;
+
   delete m_currentStack;
 
 #ifdef HAS_KARAOKE
@@ -1260,6 +1270,13 @@
     g_windowManager.ActivateWindow(startWindow);
   }
 
+  //spotify
+  if (g_advancedSettings.m_spotifyEnable)
+  {
+    g_spotifyInterface = new SpotifyInterface;
+    g_spotifyInterface->connect(false);
+  }
+
 #ifdef HAS_PYTHON
   g_pythonParser.m_bStartup = true;
 #endif
Index: xbmc/AdvancedSettings.cpp
===================================================================
--- xbmc/AdvancedSettings.cpp	(revision 27482)
+++ xbmc/AdvancedSettings.cpp	(arbetskopia)
@@ -60,6 +60,15 @@
   m_karaokeAlwaysEmptyOnCdgs = 1;
   m_karaokeUseSongSpecificBackground = 0;
 
+  //spotify
+  m_spotifyEnable = true;
+  m_spotifyUseHighBitrate = true;
+  m_spotifyUsername = "";
+  m_spotifyPassword = "";
+  m_spotifyCacheFolder = "/tmp/spotify/";
+  m_spotifyMaxSearchArtists = 50;
+  m_spotifyMaxSearchAlbums = 50;
+  m_spotifyMaxSearchTracks = 100;
   m_audioDefaultPlayer = "paplayer";
   m_audioPlayCountMinimumPercent = 90.0f;
   m_audioHost = "default";
@@ -543,6 +552,20 @@
     XMLUtils::GetInt(pElement, "movielength", m_iMythMovieLength);
   }
 
+  //spotify
+  pElement = pRootElement->FirstChildElement("spotify");
+  if (pElement)
+  {
+    XMLUtils::GetBoolean(pElement, "enable", m_spotifyEnable);
+    XMLUtils::GetBoolean(pElement, "highbitrate", m_spotifyUseHighBitrate);
+    XMLUtils::GetString(pElement, "username", m_spotifyUsername);
+    XMLUtils::GetString(pElement, "password", m_spotifyPassword);
+    XMLUtils::GetString(pElement, "cachefolder", m_spotifyCacheFolder);
+    XMLUtils::GetInt(pElement, "maxsearchartists", m_spotifyMaxSearchArtists, 0, 500);
+    XMLUtils::GetInt(pElement, "maxsearchalbums", m_spotifyMaxSearchAlbums,0,500);
+    XMLUtils::GetInt(pElement, "maxsearchtracks", m_spotifyMaxSearchTracks,0,1000);
+  }
+
   // EDL commercial break handling
   pElement = pRootElement->FirstChildElement("edl");
   if (pElement)
Index: xbmc/MusicDatabase.h
===================================================================
--- xbmc/MusicDatabase.h	(revision 27482)
+++ xbmc/MusicDatabase.h	(arbetskopia)
@@ -116,6 +116,10 @@
   void EmptyCache();
   void Clean();
   int  Cleanup(CGUIDialogProgress *pDlgProgress);
+
+  //spotify, we need a new function to remove albums from the database
+  bool RemoveAlbum(CStdString albumPath);
+
   void DeleteAlbumInfo();
   bool LookupCDDBInfo(bool bRequery=false);
   void DeleteCDDBInfo();
Index: xbmc/FileSystem/FactoryDirectory.cpp
===================================================================
--- xbmc/FileSystem/FactoryDirectory.cpp	(revision 27482)
+++ xbmc/FileSystem/FactoryDirectory.cpp	(arbetskopia)
@@ -40,6 +40,8 @@
 #include "HTTPDirectory.h"
 #include "DAVDirectory.h"
 #include "Application.h"
+//spotify
+#include "SpotifyDirectory.h"
 
 #ifdef HAS_FILESYSTEM_SMB
 #ifdef _WIN32
@@ -129,6 +131,9 @@
   if (strProtocol == "playlistmusic") return new CPlaylistDirectory();
   if (strProtocol == "playlistvideo") return new CPlaylistDirectory();
   if (strProtocol == "musicdb") return new CMusicDatabaseDirectory();
+    //spotify
+  if (strProtocol == "spotify") return new CMusicSpotifyDirectory();
+
   if (strProtocol == "musicsearch") return new CMusicSearchDirectory();
   if (strProtocol == "videodb") return new CVideoDatabaseDirectory();
   if (strProtocol == "filereader")
Index: xbmc/FileSystem/MusicDatabaseDirectory.cpp
===================================================================
--- xbmc/FileSystem/MusicDatabaseDirectory.cpp	(revision 27482)
+++ xbmc/FileSystem/MusicDatabaseDirectory.cpp	(arbetskopia)
@@ -29,6 +29,8 @@
 #include "TextureManager.h"
 #include "LocalizeStrings.h"
 #include "utils/log.h"
+//spotify
+#include "spotinterface.h"
 
 using namespace std;
 using namespace XFILE;
@@ -44,28 +46,108 @@
 
 bool CMusicDatabaseDirectory::GetDirectory(const CStdString& strPath, CFileItemList &items)
 {
-  auto_ptr<CDirectoryNode> pNode(CDirectoryNode::ParseURL(strPath));
+    //spotify artistbrowsing
+    if (strPath.Left(33) == "musicdb://2/spotifyartist/albums/")
+    {
+      return g_spotifyInterface->getBrowseArtistAlbums(strPath.c_str(), items);
+    }
+    else if (strPath.Left(34) == "musicdb://1/spotifyartist/artists/")
+    {
+      return g_spotifyInterface->getBrowseArtistArtists(strPath.c_str(), items);
+    }
+    else if (strPath.Left(26) == "musicdb://1/spotifyartist/")
+    {
+      return g_spotifyInterface->getBrowseArtistMenu(strPath.c_str(), items);
+    }
+    //spotify toplistbrowsing
+    else if (strPath.Left(35) == "musicdb://1/spotifytoplist/artists/")
+    {
+      return g_spotifyInterface->getBrowseToplistArtists(items);
+    }
+    else if (strPath.Left(34) == "musicdb://2/spotifytoplist/albums/")
+    {
+      return g_spotifyInterface->getBrowseToplistAlbums(items);
+    }
+    else if (strPath.Left(34) == "musicdb://3/spotifytoplist/tracks/")
+    {
+      return g_spotifyInterface->getBrowseToplistTracks(items);
+    }
+    //spotify albumbrowsing
+    else if (strPath.Left(25) == "musicdb://2/spotifyalbum/")
+    {
+      return g_spotifyInterface->getBrowseAlbumTracks(strPath,items);
+    }
+    //spotify search
+    else if (strPath.Left(33) == "musicdb://1/spotifysearchartist/")
+    {
+      CLog::Log(LOGWARNING, "Spotifylog: loading spotify artists from search");
+      g_spotifyInterface->getSearchArtists(items);
+      if (items.IsEmpty())
+        return false;
+      return true;
+    }
+    else if (strPath.Left(32) == "musicdb://2/spotifysearchalbums/")
+    {
+      CLog::Log(LOGWARNING, "Spotifylog: loading spotify albums from search");
+      g_spotifyInterface->getSearchAlbums(items);
+      if (items.IsEmpty())
+        return false;
+      return true;
+    }
+    else if (strPath.Left(32) == "musicdb://3/spotifysearchtracks/")
+    {
+      CLog::Log(LOGWARNING, "Spotifylog: loading spotify tracks from search");
+      g_spotifyInterface->getSearchTracks(items);
+      if (items.IsEmpty())
+        return false;
+      return true;
+    }
+    //spotify playlist
+    else if (strPath.Left(28) == "musicdb://2/spotifyplaylist/")
+    {
+      CStdString playListNr = strPath;
+      playListNr.Delete(0, 28);
+      CUtil::RemoveSlashAtEnd(playListNr);
+      g_spotifyInterface->getPlaylistTracks(items,atoi(playListNr.c_str()));
+      if (items.IsEmpty())
+        return false;
+      return true;
+    }
+    else
+    {
+    auto_ptr<CDirectoryNode> pNode(CDirectoryNode::ParseURL(strPath));
 
-  if (!pNode.get())
-    return false;
+    if (!pNode.get())
+      return false;
 
-  bool bResult = pNode->GetChilds(items);
-  for (int i=0;i<items.Size();++i)
-  {
-    CFileItemPtr item = items[i];
-    if (item->m_bIsFolder && !item->HasIcon() && !item->HasThumbnail())
+    bool bResult = pNode->GetChilds(items);
+    for (int i=0;i<items.Size();++i)
     {
-      CStdString strImage = GetIcon(item->m_strPath);
-      if (!strImage.IsEmpty() && g_TextureManager.HasTexture(strImage))
-        item->SetIconImage(strImage);
+      CFileItemPtr item = items[i];
+      if (item->m_bIsFolder && !item->HasIcon() && !item->HasThumbnail())
+      {
+        CStdString strImage = GetIcon(item->m_strPath);
+        if (!strImage.IsEmpty() && g_TextureManager.HasTexture(strImage))
+          item->SetIconImage(strImage);
+      }
     }
+
+    return bResult;
   }
-
-  return bResult;
 }
 
 NODE_TYPE CMusicDatabaseDirectory::GetDirectoryChildType(const CStdString& strPath)
 {
+  //spotify, we need to force artist or album views, not a good way... but it works for now
+  if (strPath.Left(34) == "musicdb://1/spotifyartist/artists/" || strPath.Left(26) == "musicdb://1/spotifyartist/")
+  {
+    return NODE_TYPE_ARTIST;
+  }
+  if (strPath.Left(33) == "musicdb://2/spotifyartist/albums/")
+  {
+    return NODE_TYPE_ALBUM;
+  }
+
   auto_ptr<CDirectoryNode> pNode(CDirectoryNode::ParseURL(strPath));
 
   if (!pNode.get())
Index: xbmc/MusicDatabase.cpp
===================================================================
--- xbmc/MusicDatabase.cpp	(revision 27482)
+++ xbmc/MusicDatabase.cpp	(arbetskopia)
@@ -1575,6 +1575,33 @@
   return false;
 }
 
+//spotify
+bool CMusicDatabase::RemoveAlbum(CStdString albumPath)
+{
+  albumPath.Delete(0,12);
+  CUtil::RemoveSlashAtEnd(albumPath);
+  try
+  {
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS.get()) return false;
+
+    CStdString strSQL;
+    strSQL=FormatSQL("delete from song where idAlbum=%s", albumPath.c_str());
+    m_pDS->exec(strSQL.c_str());
+    strSQL=FormatSQL("delete from album where idAlbum=%s", albumPath.c_str());
+    m_pDS->exec(strSQL.c_str());
+    this->CleanupSongs();
+    this->CleanupAlbums();
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s failed", __FUNCTION__);
+  }
+
+  return false;
+}
+
 void CMusicDatabase::EmptyCache()
 {
   m_artistCache.erase(m_artistCache.begin(), m_artistCache.end());
@@ -1851,7 +1878,8 @@
         CUtil::RemoveSlashAtEnd(strFileName);
       }
 
-      if (!CFile::Exists(strFileName))
+      //spotify, dont delete it if its a spotify song
+      if (CUtil::GetExtension(strFileName) !=".spotify" && !CFile::Exists(strFileName))
       { // file no longer exists, so add to deletion list
         strSongsToDelete += m_pDS->fv("song.idSong").get_asString() + ",";
       }
Index: xbmc/Makefile.in
===================================================================
--- xbmc/Makefile.in	(revision 27482)
+++ xbmc/Makefile.in	(arbetskopia)
@@ -14,7 +14,8 @@
 
 INCLUDES+=-Ilib/libcdio/libcdio/include
 
-SRCS=Application.cpp \
+SRCS=spotinterface.cpp \
+     Application.cpp \
      CueDocument.cpp \
      GUISettings.cpp \
      GUIWindowSettings.cpp \
Index: xbmc/GUIViewStateMusic.cpp
===================================================================
--- xbmc/GUIViewStateMusic.cpp	(revision 27482)
+++ xbmc/GUIViewStateMusic.cpp	(arbetskopia)
@@ -101,6 +101,16 @@
   SaveViewToDb(m_items.m_strPath, WINDOW_MUSIC_NAV, &g_settings.m_viewStateMusicNavSongs);
 }
 
+//spotify, why? well by doing this we make sure that its impossible to change the order the menu items are displayed
+CGUIViewStateSpotifyLibrary::CGUIViewStateSpotifyLibrary(const CFileItemList& items) : CGUIViewStateWindowMusic(items)
+{
+}
+
+void CGUIViewStateSpotifyLibrary::SaveViewState()
+{
+}
+
+
 CGUIViewStateMusicDatabase::CGUIViewStateMusicDatabase(const CFileItemList& items) : CGUIViewStateWindowMusic(items)
 {
   CMusicDatabaseDirectory dir;
@@ -509,6 +519,18 @@
 
 void CGUIViewStateWindowMusicNav::AddOnlineShares()
 {
+  //spotify, only if we do use spotify
+  CLog::Log(LOGDEBUG,"Adding spotify share");
+  if (g_advancedSettings.m_spotifyEnable)
+  {
+    CMediaSource share;
+    share.strName="Spotify"; // main menu
+    share.strPath = "spotify://menu";
+    share.m_strThumbnailImage = CUtil::GetDefaultFolderThumb("special://xbmc/media/spotify_core_logo.png");
+    share.m_iDriveType = CMediaSource::SOURCE_TYPE_LOCAL;
+    m_sources.push_back(share);
+  }
+
   if (!g_advancedSettings.m_bVirtualShares) return;
   for (int i = 0; i < (int)g_settings.m_musicSources.size(); ++i)
   {
Index: xbmc/GUIDialogContextMenu.h
===================================================================
--- xbmc/GUIDialogContextMenu.h	(revision 27482)
+++ xbmc/GUIDialogContextMenu.h	(arbetskopia)
@@ -112,7 +112,9 @@
                       CONTEXT_BUTTON_USER7,
                       CONTEXT_BUTTON_USER8,
                       CONTEXT_BUTTON_USER9,
-                      CONTEXT_BUTTON_USER10
+                      CONTEXT_BUTTON_USER10,
+                      //spotify add a button for removing albums from lib
+                      CONTEXT_BUTTON_SPOTIFY_REMOVE_ALBUM
                     };
 
 class CContextButtons : public std::vector< std::pair<CONTEXT_BUTTON, CStdString> >
Index: xbmc/GUIWindowMusicNav.cpp
===================================================================
--- xbmc/GUIWindowMusicNav.cpp	(revision 27482)
+++ xbmc/GUIWindowMusicNav.cpp	(arbetskopia)
@@ -173,6 +173,10 @@
         m_startDirectory = returning ? destPath : "";
       }
 
+      //spotify  we still want a library view if we have spotify enabled
+      if (g_advancedSettings.m_spotifyEnable)
+        return true;
+
       //  base class has opened the database, do our check
       DisplayEmptyDatabaseMessage(m_musicdatabase.GetSongsCount() <= 0);
 
@@ -603,6 +607,13 @@
       if (strcmp(g_settings.m_defaultMusicLibSource, ""))
         buttons.Add(CONTEXT_BUTTON_CLEAR_DEFAULT, 13403); // clear default
     }
+
+    //if (!item->IsParentFolder() && nodetype == NODE_TYPE_ALBUM && m_vecItems->GetContentType() == "spotifyalbum")
+    //{
+      //spotify add the remove album button
+      buttons.Add(CONTEXT_BUTTON_SPOTIFY_REMOVE_ALBUM,"Remove album");
+    //}
+
     NODE_TYPE childtype = dir.GetDirectoryChildType(item->m_strPath);
     if (childtype == NODE_TYPE_ALBUM               ||
         childtype == NODE_TYPE_ARTIST              ||
@@ -667,8 +678,23 @@
   if (itemNumber >= 0 && itemNumber < m_vecItems->Size())
     item = m_vecItems->Get(itemNumber);
 
+  //spotify
+  CSongMap songMap;
+  CMusicDatabase db;
+
   switch (button)
   {
+  //spotify remove the album
+  case CONTEXT_BUTTON_SPOTIFY_REMOVE_ALBUM:
+        CLog::Log(LOGERROR, "spotifylog: försöker ta bort %s", item->m_strPath.c_str());
+        db.Open();
+        db.BeginTransaction();
+        db.RemoveAlbum(item->m_strPath);
+        db.CommitTransaction();
+        db.Close();
+        Update(m_history.GetParentPath());
+        return true;
+
   case CONTEXT_BUTTON_INFO:
     {
       if (!item->IsVideoDb())
Index: xbmc/AdvancedSettings.h
===================================================================
--- xbmc/AdvancedSettings.h	(revision 27482)
+++ xbmc/AdvancedSettings.h	(arbetskopia)
@@ -61,6 +61,16 @@
     CStdString m_audioDefaultPlayer;
     float m_audioPlayCountMinimumPercent;
 
+    //Spotify
+    bool m_spotifyEnable;
+    bool m_spotifyUseHighBitrate;
+    CStdString m_spotifyUsername;
+    CStdString m_spotifyPassword;
+    CStdString m_spotifyCacheFolder;
+    int m_spotifyMaxSearchArtists;
+    int m_spotifyMaxSearchAlbums;
+    int m_spotifyMaxSearchTracks;
+
     float m_videoSubsDelayRange;
     float m_videoAudioDelayRange;
     int m_videoSmallStepBackSeconds;
Index: xbmc/Settings.cpp
===================================================================
--- xbmc/Settings.cpp	(revision 27482)
+++ xbmc/Settings.cpp	(arbetskopia)
@@ -104,7 +104,8 @@
   m_fPixelRatio = 1.0f;
 
   m_pictureExtensions = ".png|.jpg|.jpeg|.bmp|.gif|.ico|.tif|.tiff|.tga|.pcx|.cbz|.zip|.cbr|.rar|.m3u|.dng|.nef|.cr2|.crw|.orf|.arw|.erf|.3fr|.dcr|.x3f|.mef|.raf|.mrw|.pef|.sr2|.rss";
-  m_musicExtensions = ".nsv|.m4a|.flac|.aac|.strm|.pls|.rm|.rma|.mpa|.wav|.wma|.ogg|.mp3|.mp2|.m3u|.mod|.amf|.669|.dmf|.dsm|.far|.gdm|.imf|.it|.m15|.med|.okt|.s3m|.stm|.sfx|.ult|.uni|.xm|.sid|.ac3|.dts|.cue|.aif|.aiff|.wpl|.ape|.mac|.mpc|.mp+|.mpp|.shn|.zip|.rar|.wv|.nsf|.spc|.gym.adx|.dsp|.adp|.ymf|.ast|.afc|.hps|.xsp|.xwav|.waa|.wvs|.wam|.gcm|.idsp|.mpdsp|.mss|.spt|.rsd|.mid|.kar|.sap|.cmc|.cmr|.dmc|.mpt|.mpd|.rmt|.tmc|.tm8|.tm2|.oga|.url|.pxml|.tta|.rss|.cm3|.cms|.dlt";
+  //spotify, enables us to remove the .spotify extension 
+  m_musicExtensions = ".spotify|.nsv|.m4a|.flac|.aac|.strm|.pls|.rm|.rma|.mpa|.wav|.wma|.ogg|.mp3|.mp2|.m3u|.mod|.amf|.669|.dmf|.dsm|.far|.gdm|.imf|.it|.m15|.med|.okt|.s3m|.stm|.sfx|.ult|.uni|.xm|.sid|.ac3|.dts|.cue|.aif|.aiff|.wpl|.ape|.mac|.mpc|.mp+|.mpp|.shn|.zip|.rar|.wv|.nsf|.spc|.gym.adx|.dsp|.adp|.ymf|.ast|.afc|.hps|.xsp|.xwav|.waa|.wvs|.wam|.gcm|.idsp|.mpdsp|.mss|.spt|.rsd|.mid|.kar|.sap|.cmc|.cmr|.dmc|.mpt|.mpd|.rmt|.tmc|.tm8|.tm2|.oga|.url|.pxml|.tta|.rss|.cm3|.cms|.dlt";
   m_videoExtensions = ".m4v|.3g2|.3gp|.nsv|.tp|.ts|.ty|.strm|.pls|.rm|.rmvb|.m3u|.ifo|.mov|.qt|.divx|.xvid|.bivx|.vob|.nrg|.img|.iso|.pva|.wmv|.asf|.asx|.ogm|.m2v|.avi|.bin|.dat|.mpg|.mpeg|.mp4|.mkv|.avc|.vp3|.svq3|.nuv|.viv|.dv|.fli|.flv|.rar|.001|.wpl|.zip|.vdr|.dvr-ms|.xsp|.mts|.m2t|.m2ts|.evo|.ogv|.sdp|.avs|.rec|.url|.pxml|.vc1|.h264|.rcv|.rss|.mpls";
   // internal music extensions
   m_musicExtensions += "|.sidstream|.oggstream|.nsfstream|.asapstream|.cdda";
Index: xbmc/GUIViewStateMusic.h
===================================================================
--- xbmc/GUIViewStateMusic.h	(revision 27482)
+++ xbmc/GUIViewStateMusic.h	(arbetskopia)
@@ -71,6 +71,16 @@
   virtual void SaveViewState();
 };
 
+//spotify
+class CGUIViewStateSpotifyLibrary : public CGUIViewStateWindowMusic
+{
+public:
+  CGUIViewStateSpotifyLibrary(const CFileItemList& items);
+
+protected:
+  virtual void SaveViewState();
+};
+
 class CGUIViewStateWindowMusicNav : public CGUIViewStateWindowMusic
 {
 public:
